\documentclass{llncs}
\pagestyle{plain}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{mathpartir}
\newcommand{\interp}[1]{\llbracket #1 \rrbracket}
\newcommand{\maps}{\colon}
\renewcommand{\:}{\colon}
\newcommand{\FinSet}{\mathrm{FinSet}}
\newcommand{\Set}{\mathrm{Set}}
\newcommand{\Cat}{\mathrm{Cat}}
\newcommand{\Calc}{\mathrm{Calc}}
\newcommand{\Mon}{\mathrm{Mon}}
\newcommand{\BoolAlg}{\mathrm{BoolAlg}}
\renewcommand{\Form}{\mathrm{Form}}
\newcommand{\leftu}{\mathrm{left}}
\newcommand{\rightu}{\mathrm{right}}
\newcommand{\send}{\mathrm{send}}
\newcommand{\recv}{\mathrm{recv}}
\newcommand{\comm}{\mathrm{comm}}
\renewcommand{\quote}[1]{``#1"}
\newcommand{\deref}[1]{\mathrm{eval}(#1)}
\newcommand{\op}{\mathrm{op}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\quotep}[1]{\mathsf{@}#1}
\newcommand{\red}{\rightarrow}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\pzero}{\mathbin{0}}

\makeatletter
\gdef\tshortstack{\@ifnextchar[\@tshortstack{\@tshortstack[c]}}
\gdef\@tshortstack[#1]{%
  \leavevmode
  \vtop\bgroup
    \baselineskip-\p@\lineskip 3\p@
    \let\mb@l\hss\let\mb@r\hss
    \expandafter\let\csname mb@#1\endcsname\relax
    \let\\\@stackcr
    \@ishortstack}
\makeatother

\title{Logic, resource, and reflection}
\author{
L.G. Meredith\inst{1}\\
\and
Michael Stay\inst{2}\\
}
\institute{
  {RChain Cooperative}\\
  \email{\fontsize{8}{8}\selectfont lgreg.meredith@rchain.coop}
  \and
  {Pyrofex Corp.}\\
  \email{\fontsize{8}{8}\selectfont stay@pyrofex.net}\\
}
\begin{document}
\maketitle
\begin{abstract}
\noindent
  We present an algorithm for deriving a spatial-behavioral type
  system and term assignment algorithm from a formal presentation of a
  interactive computational calculus. This turns out to identify a
  species of category which we offer an axiomatic characterization of
  interaction categories. 
\end{abstract}

\section{Introduction and motivation}

In groundbreaking work, Abramsky, Gay, and Nagarajan put forward the
idea of interaction categories to give a categorical framework for
interactive models of computing.\cite{DBLP:conf/nato/AbramskyGN96}
Indeed, interactive models of computation are relatively new and offer
distinct insights because they include the computational environment
as part of the computational model. Examples include the {\pic}, in
fact, all the mobile process calculi, as well as the
$\lambda$-calculus. \cite{milner91polyadicpi}\cite{Barendregt84} However,
interaction categories take inspiration from linear logic rather than
to say axiomatically what interaction is.

We put forward a simple, intuitive axiomatic characterization of
interaction and use this to derive not only a logic but a proof theory
and term assignment algorithm for all systems satisfying these
axioms. The resulting structure identifies a species of category and
we offer this as an axiomatic characterization of interaction
categories.

\subsection{Intuitions}

The key idea in this construction is to use both the evaluation
context of Meredith and Stay \cite{DBLP:journals/corr/StayM15}, and
computational reflection, similar to what is found in Meredith and
Radestock \cite{DBLP:journals/entcs/MeredithR05}, to build a proof
theory for an interactive rewrite system. The proof theory enjoys a
cut elimination property that corresponds exactly with the notion of
computation embodied in the interactive rewrite system.

The requirement that the rewrite system is interactive means the left
hand side of every rewrite rule will necessarily be a term built from
a term constructor, say $\mathsf{K}$, taking at least two terms as
arguments. That is, when viewed as a piece of syntax it is at least a
tuple of terms. This bipartite split is what characterizes
interaction. One of the arguments is the program and one is the
environment. For example, in $\lambda-calculus$ application functions
in the role of $\mathsf{K}$, and the term in function position is
usually considered the program, while the term in argument position
constitutes an environment. In the {\pic} parallel composition
functions in the role of $\mathsf{K}$ while either parand can be
considered program and the other environment.

Given an interactive rewrite system, we can introduce an evaluation
context to control evaluation and force a distinction between a frozen
or reified computation (referred to as a tensor) and an active
computation (referred to as a cut). Specifically, a cut forms the
redex with an evaluation context supplied, and the tensor is denied
the evaluation context, effectively rendering it a data structure. Of
course, the data is inaccessible until there is a means to unpack
it. We introduce a new term to the system (referred to as a par term)
as the principal means to extract the data from a tensor. In fact, we
introduce two different kinds of par terms, one for wiring evaluation
in parallel and one in series. More on this in subsequent sections.

The use of the term constructor that forms a redex as a data structure
is the essential use of reflection. The lack of a reduction context
gives us the ability to suspend computation. Having suspended it, we
reify computation as data, and use par to unpack the data making up
the computation. Completing the circle, we introduce a means for
having tensors and pars interact with each other (referred to as the tensor-par cut
rule) which constitutes the means to reflect computational data back into
actual computations.

It turns out that denying the evaluation context is not the only way
to suspend computation. We can also form contexts. In this case, we
only admit 1-holed contexts, ranged over by $\chi$. With contexts we can
define a notion of rely-guarantee, two notions actually (indicated by
the operations $(- \rhd -)$ and $(- \lhd -)$), as a redex term constructor
might not be commutative.

\begin{eqnarray*}
\tau \rhd_{\mathsf{K}} \tau' & \triangleq & \{ u \quad | \quad \exists t. u = \mathsf{!}\mathsf{K}_{\boxempty}^{r}(t, \boxempty),\forall u' : \tau. (\exists \rho : u@u' \rightarrow v) \Rightarrow v:\tau' \} \\
\tau' \lhd_{\mathsf{K}} \tau & \triangleq & \{ t \quad | \quad \exists u. t = \mathsf{K}_{\boxempty}^{l}(\boxempty, u)\mathsf{!},\forall t' : \tau. (\exists \rho: t@t' \rightarrow v) \Rightarrow v : \tau' \}
\end{eqnarray*}

In the sequel we drop the subscript on the triangles if it's understood from
context. We use the notation $\chi @ t$ to mean the term formed by
substituting $t$ for hole in $\chi$. Thus, $\mathsf{K}(t, \boxempty)@u = \mathsf{K}(t, \boxempty)[u/\boxempty] = \mathsf{K}(t,u)$ and similarly, $\mathsf{K}(\boxempty, u)@t = \mathsf{K}(\boxempty, u)[t/\boxempty] = \mathsf{K}(t,u)$

To give some examples, the comm rule of rho-calculus is given by

\begin{equation*}
  \mathsf{for}( y \leftarrow x )P \quad | \quad x\mathsf{!}(Q) \rightarrow P\{ @Q/y \}
\end{equation*}

In this case $\mathsf{K}$ is parallel composition, and the revised, resource
constrained comm rule, looks like

\begin{equation*}
  \mathsf{R} | \mathsf{for}( y \leftarrow x )P \quad | \quad x\mathsf{!}(Q) \rightarrow P\{ @Q/y \}
\end{equation*}

In the lambda calculus, $\beta$-reduction is given by

\begin{equation*}
  (\lambda x.M)N \rightarrow M\{ N/x \}
\end{equation*}  

$\mathsf{K}$ is application, and the revised, resource constrained $\beta$-reduction is given by

\begin{equation*}
  \mathsf{R}((\lambda x.M)N) \rightarrow M\{ N/x \}
\end{equation*}    

In what follows we will focus on calculi that don't employ binding
operators and so-called nominal phenomena. This is not to say that we
can't handle nominal phenomena, just that the content is already
complex enough and we want to focus on the core ideas.


\subsection{Related work}
In many ways this work is inspired by and derives from domain theory
in logical form (DTLF).\cite{DBLP:journals/apal/Abramsky91} In much
the same way that DTLF takes as input a notion of computation encoded
in a domain theory and produces a logical system encoding the same
notion of computation, but from the logical view, this is an algorithm
that takes as input a notion of computation encoded as a Lawvere
theory (\cite{DBLP:journals/entcs/HylandP07}) and produces a new
Lawvere theory that is resource constrained and enjoys a type system
that guarantees a range of security and liveness properties, while at
the same time having the tightest possible conformance to the original
notion of computation. In particular, the resulting type theory is
also a logic enjoying a notion of cut-elimination and proof
normalization that matches exactly with the operational semantics of
the original theory. As such, it automatically enjoys a Curry-Howard
correspondence.

Other inspiration and guidance come from the two major branches in the
development of behavioral types. One branch derives from the spatial
logics of Caires \cite{DBLP:conf/fossacs/Caires04}, et al, while the
other derives from the session types of Wadler, et
al. \cite{DBLP:journals/jfp/Wadler14} The former is predominantly
model theory based, while the latter is predominantly proof theory
based. In the spatial logics branch the negation is largely set-based,
while in the session types work the negation is related to the
reduction of terms. This construction brings both branches together
and offers both model theory and proof theory that enjoys a full
abstraction-like property.

The discussion would not be complete without mentioning
blockchain. While the idea of resource limiting computation certainly
has a long and illustrious history, inspired by catalysts in chemical
and biochemical reactions, it has immediate practical application in
blockchain platforms such as RChain and Ethereum. Here, the
programming model is throttled by the existence of a resource. The
cost of obtaining that resource constitutes a prophylactic against
denial-of-service attacks. Specifically, an attacker attempting to
deploy computations that run forever or take up infinite storage must
pay for the corresponding infinite resources necessary to enable the
infinite computations.

\subsection{Notation}
We use 

\begin{itemize}
  \item $\Gamma , \Delta , \Xi$  to range over type contexts;
  \item $\rhd , \lhd$ for left and right residuation;
  \item $(-)_{\perp}$ and $ _{\perp}(-)$  for left and right negations;
  \item $!(-)$ and $(-)!$  for left and right abstractions; 
  \item $\rho$ to range over rewrite rules;
  \item $\chi$ to range over contexts;
  \item $\bindnasrepma, \otimes, \sqcap, \sqcup$ for logical connectives derived from $\mathsf{K}$; $\sqcap$ serial, $\otimes$ parallel
  \item both double and single sided $\vdash$ for typing judgments;
  \item $\Rightarrow$ for meta level logical implication.
\end{itemize}

\section{Construction}
To illustrate the general construction we apply it to the simplest
possible interactive rewrite theory, consisting of a single sort, $T$,
for term, a single constant, $\mathsf{c}$, and a single term constructor $\mathsf{K}$, along
with left and right identities for $\mathsf{K}$ (which are, of course,
constants). It has a single rewrite rule, $\rho$.

We add a resource, $\mathsf{R}$, which can be thought of as either an evaluation
context, or as a constant. In the resourced theory, the rewrite rule
only applies in an evaluation context.

Then we add a notion of 1-holed context. We add a new sort, $\chi_{T}$, then a
constant for the hole, together with left and right maps for placing
the hole in either side of $\mathsf{K}$, along with left and right maps $!(-)$ and
$(-)!$ essentially for treating contexts as abstractions. We add a map
$@(-,-)$ for substituting a term into a context marked as an
abstraction.

It is important to note that we do not allow the rewrite rule to
operate on contexts. Thus, there are two ways to suspend computation:
withholding a resource, or forming an abstraction.  Input to the
algorithm It is to be understood that the initial theory is provided
as input to the system. As mentioned earlier, this is an algorithm
that takes as input a notion of computation encoded as a Lawvere
theory and produces a new Lawvere theory that is resource constrained
and enjoys a type system that guarantees a range of security and
liveness properties.

We encode term calculi as Lawvere theories by starting with the theory
of reflexive directed multigraphs:

\begin{itemize}
  \item one sort $T$
  \item function symbols $s, t: T \rightarrow T$
  \item equations $ss = ts = s$, $st = tt = t$
\end{itemize}

To this theory, we add function symbols for each term constructor and
reduction rule.  We also add equations for the source and target of
each reduction rule.  For example, we can model the $\mathsf{SKI}$ combinator
calculus by adding

\begin{itemize}
  \item $S, K, I : 1 \rightarrow T$
  \item $(- -) : T^{2} \rightarrow T$
  \item $\sigma : T^{3} \rightarrow T$
  \item $\kappa : T^{2} \rightarrow T$
  \item $\iota : T \rightarrow T$
  \item $s\sigma(x, y, z) = (((S x) y) z$
  \item $t\sigma(x, y, z) = ((x z) (y z))$
  \item $s\kappa(x, y) = ((K x) y)$
  \item $t\kappa(x, y) = x$
  \item $s\iota(x) = (I x)$
  \item $t\iota(x) = x$
\end{itemize}

We'll use the following symbols to talk about a generic term calculus
with at least one binary term constructor and one rewrite rule that
uses the term constructor as its source.

\begin{itemize}
  \item $\mathsf{c}, l_{\mathsf{K}}, r_{\mathsf{K}} : 1 -> T$
  \item $\mathsf{K} : T^{2} \rightarrow T$
  \item $\rho : T^{2} \rightarrow T$             %%//( \x -> M N) → M{N/x}     for( y <- x )P | x!(Q) → P{@Q/y}$
  \item $\mathsf{K}(l_{\mathsf{K}}, u) = u$
  \item $\mathsf{K}(t, r_{\mathsf{K}}) = t$
  \item $s(\rho(t,u)) = \mathsf{K}(t, u)$
  \item $t(\rho(t,u)) = f(t,u)$
\end{itemize}

Note that $\mathsf{K}$ may not be commutative, so we ask for either a left
identity, $l_{\mathsf{K}}$, or a right identity, $r_{\mathsf{K}}$, or if we have both they must
coincide.

We proceed in stages, producing first a resourced version of the
theory that requires an evaluation context to run the rewrite rule,
then producing a contextualized version of the theory.

\subsubsection{Resourced theory}
\begin{itemize}
  \item $\mathsf{c}, l_{\mathsf{K}}, r_{\mathsf{K}} : 1 \rightarrow T$
  \item $\mathsf{K} : T^{2} \rightarrow T$
  \item $\mathsf{R} : T \rightarrow T$
  \item $\bindnasrepma_{\rho} : T^{2} \rightarrow T$
  \item $\sqcup_{\rho} : T^{2} \rightarrow T$
  \item $\rho : T^{2} \rightarrow T$             %%//( \x \rightarrow M N) → M{N/x}     for( y <- x )P | x!(Q) → P{@Q/y}
  \item $\mathsf{K}(l_{\mathsf{K}}, u) = u$
  \item $\mathsf{K}(t, r_{\mathsf{K}}) = t$
  \item $s(\rho(t,u)) = \mathsf{R}\mathsf{K}(t, u)$
  \item $t(\rho(t,u)) = f(t,u)$                    %%// f can mention R, e.g. if R is not a linear resource
\end{itemize}

\subsubsection{Contextualized Resourced theory}
We add a new sort, $\chi_{T}$, and the following maps

\begin{itemize}
  \item $\mathsf{c}, l_{\mathsf{K}}, r_{\mathsf{K}} : 1 \rightarrow T$
  \item $\mathsf{K} : T^{2} \rightarrow T$
  \item $\boxempty : 1 \rightarrow \chi_{T}$
  \item $\mathsf{K}_{\boxempty}^{l} : \chi_{T}^{2} \rightarrow \chi_{T}$
  \item $\mathsf{K}_{\boxempty}^{r} : T x \chi_{T} \rightarrow \chi_{T}$
  \item $!(-) : \chi_{T}  \rightarrow T$
  \item $(-)! : \chi_{T}  \rightarrow T$
  \item $@ : T^{2} \rightarrow T$
  \item $@_{\boxempty} : \chi_{T}^{2} \rightarrow T$
  \item $\mathsf{R} : T \rightarrow T$
  \item $\bindnasrepma_{\rho} : T^{2} \rightarrow T$
  \item $\sqcup_{\rho} : T^{2} \rightarrow T$
  \item $\rho : T^{2} \rightarrow T$             %%//( \x -> M N) -> M{N/x}     for( y <- x )P | x!(Q) -> P{@Q/y}
  \item $s(\rho(t,u)) = \mathsf{R}\mathsf{K}(t, u)$ 
  \item $t(\rho(t,u)) = f(t,u)$          %%// f can mention R, e.g. if R is not a linear resource
  \item $\mathsf{K}(l_{\mathsf{K}}, u) = u$
  \item $\mathsf{K}(t, r_{\mathsf{K}}) = t$
  \item $@(\boxempty !,t) = t$
  \item $@(!\boxempty,t) = t$
  \item $@(\mathsf{K}_{\boxempty}^{l} (\chi, t)!, u) = \mathsf{K}(@_{\boxempty}(\chi, u), t)$
  \item  $@(!\mathsf{K}_{\boxempty}^{r} (t, \chi), u) = \mathsf{K}(t, @_{\boxempty}(\chi, u))$
\end{itemize}

As mentioned before, the basic notion of arrow is given by

\begin{eqnarray*}
  \tau \rhd_{\mathsf{K}} \tau' & \triangleq  & \{ u | \exists t. u = !\mathsf{K}_{\boxempty}^{r}(t, \boxempty),\forall u':\tau. (\exists \rho : u@u'\rightarrow v) \Rightarrow v:\tau' \} \\
  \tau'\lhd_{\mathsf{K}} \tau & \triangleq  & \{ t | \exists u. t = \mathsf{K}_{\boxempty}^{l}(\boxempty, u)!,\forall t':\tau. (\exists \rho : t@t'\rightarrow v) \Rightarrow v:\tau'\}
\end{eqnarray*}

However, they can be generalized to

\begin{eqnarray*}
  \tau \rhd_{\mathsf{K}} \tau' & \triangleq  & \{ u | \exists t, \chi. u = !\mathsf{K}_{\boxempty}^{r}(t, \chi),\forall u':\tau. (\exists \rho : u@u'\rightarrow v) \Rightarrow v:\tau' \} \\
  \tau'\lhd_{\mathsf{K}} \tau & \triangleq  & \{ t | \exists u, \chi. t = \mathsf{K}_{\boxempty}^{l}(\chi, u)!,\forall t':\tau. (\exists \rho : t@t'\rightarrow v) \Rightarrow v:\tau'\}
\end{eqnarray*}

which allows the hole to be buried, rather than at the top level,

\subsection{Types}
\begin{mathpar}
  \inferrule* [lab=type] {} { \tau \bc  \top  | \tau \rhd \tau | \tau \lhd \tau | \mathsf{C} | \{\} | \tau \cup \tau | \mathsf{R}\tau | \mathsf{K}(\tau,\tau) | \rho_{\otimes}(\tau,\tau) | \rho_{\bindnasrepma}(\tau,\tau) | \rho_{\sqcap}(\tau,\tau) | \rho_{\sqcup}(\tau,\tau) }
\end{mathpar}

\subsubsection{Abbreviations}
\begin{eqnarray*}
  \tau^{\perp} & = & \tau \rhd r_{\mathsf{K}} \\
  \tau^{\circ} & = & \tau \rhd \{\} \\
  ^{\perp}\tau & = & l_{\mathsf{K}} \lhd \tau \\
  ^{\circ}\tau & = & \{\} \lhd \tau
\end{eqnarray*}

\section{Intuitionistic Term assignment}

\begin{table}[htp]
  \center{
    \fbox{
      \begin{tabular}{c|c|c}
        & structure & destructure \\
        \hline
        parallel & tensor ($\otimes$) & par ($\bindnasrepma$) \\
        \hline
        serial & serialize ($\sqcap$) & deserialize ($\sqcup$) \\
      \end{tabular}
    }
  }
  \caption{Wiring operations}
\end{table}

\subsection{Terms, their types and cuts}
\begin{mathpar}
  \inferrule* [lab=constants] {} {\vdash \mathsf{c} : \mathsf{C}}

  \inferrule* [lab=$\rho_{\otimes}$]{\Gamma \vdash t : \tau  \Delta \vdash u : \tau'}{\Gamma, \Delta \vdash \mathsf{K}(t, u) : \rho_{\otimes}(\tau, \tau')}

  \inferrule* [lab=$\rho_{\bindnasrepma}$]{\Gamma \vdash t : \tau, u : \tau'}{\Gamma \vdash \bindnasrepma_{\rho} (t, u) : \rho_{\bindnasrepma}(\tau, \tau')}

\inferrule* [lab=$\rho_{\bindnasrepma \perp \otimes}$]{\Gamma \vdash \bindnasrepma_{\rho} (t_{1}, t_{2}) : \rho_{\bindnasrepma}(\tau_{1}^{\perp}, \tau_{2}^{\perp})  \Delta \vdash \mathsf{K}(t_{3}, t_{4}) : \rho_{\otimes}(\tau_{1}, \tau_{2}) }{\Gamma, \Delta \vdash \mathsf{R}(\mathsf{K}(\mathsf{K}(t_{1}, t_{3}), \mathsf{K}(t_{2}, t_{4}))) : \mathsf{R}(r_{\mathsf{K}})}
  
%% \tau \rhd \tau' = { u | \exists t,\chi. u = !\mathsf{K}_{\boxempty}^{r}(t, \chi),\forall u':\tau. (\exists \rho: u@u' \rightarrow v) \Rightarrow v:\tau' }
%% \tau\perp = \tau \rhd r_{\mathsf{K}} = { u | \exists t,\chi. u = !\mathsf{K}_{\boxvoid}^{r}(t, \chi),\forall u':\tau. (\exists \rho: u@u' \rightarrow v) \Rightarrow v:r_{\mathsf{K}} }

\inferrule* [lab=$\rho_{\sqcap}$]{\Gamma \vdash t : \tau, u : \tau'}{\Gamma \vdash \mathsf{K}(t,u) : \rho_{\sqcap}(\tau,\tau')}

\inferrule* [lab=$\rho_{\sqcup}$]{\Gamma \vdash t : \tau, u : \tau'}{\Gamma \vdash \sqcup_{\rho}(t,u) : \rho_{\sqcup}(\tau,\tau')}

\inferrule* [lab=$\rho_{\sqcup \perp \sqcap}$]{\Gamma \vdash \sqcup_{\rho} (t_{1}, t_{2}) : \rho_{\sqcup}(\tau_{3} \rhd \tau_{1}^{\perp}, \tau_{3})  \Delta \vdash \mathsf{K}(t_{3}, t_{4}) : \rho_{\sqcap}(\tau_{2} \rhd \tau_{1}, \tau_{2})}{\Gamma, \Delta \vdash \mathsf{R}(\mathsf{K}(\mathsf{K}(t_{1}, t_{2}), \mathsf{K}(t_{3}, t_{4}))) : \mathsf{R}(r_{\mathsf{K}})}

\inferrule* [lab=$\rho_{\perp}$]{\Gamma \vdash t' : \tau^{\perp}, \Delta \vdash t : \tau }{\Gamma, \Delta \vdash \mathsf{R}(\mathsf{K}(t',t)) : \mathsf{R}(r_{\mathsf{K}})}

\end{mathpar}
\subsection{Contexts, their types and cuts}
Below we identify the formation of each kind of context: tensor-parallel, tensor-serial, par-parallel, and par-serial.

\subsubsection{Axiom}

\begin{mathpar}
  \inferrule* [lab=axiom] {} {\boxempty : \tau \vdash \boxempty : \tau}
\end{mathpar}

\subsubsection{Left and right context formation and cut}

\begin{mathpar}
  \inferrule* [lab=left-arrow] {\Gamma, \boxempty : \tau  \vdash \chi : \tau'} {\Gamma \vdash \chi ! : \tau' \lhd \tau}

  \inferrule* [lab=right-arrow] {\Gamma, \boxempty : \tau  \vdash \chi : \tau'} {\Gamma \vdash !\chi : \tau \rhd \tau'}

  \inferrule* [lab=context-cut-left] {\Gamma \vdash \mathsf{K}(\boxempty,u)! : \tau' \lhd \tau,  \Delta \vdash t : \tau}{\Gamma, \Delta \vdash \mathsf{R}(\mathsf{K}(t,u)) : \mathsf{R}\tau'}

  \inferrule* [lab=context-cut-right] {\Gamma \vdash !\mathsf{K}(t,\boxempty) : \tau \rhd \tau',  \Delta \vdash u : \tau} {\Gamma, \Delta \vdash \mathsf{R}(\mathsf{K}(t,u)) : \mathsf{R}\tau'}
\end{mathpar}
  
\subsection{Classical Term assignment}
In the classical setting we transform double-sided sequents

\begin{mathpar}
  \inferrule* [lab=axiom] {} {\boxempty : \tau \vdash \boxempty : \tau}
\end{mathpar}

to single sided sequents

\begin{mathpar}
  \inferrule* [lab=axiom] {} { \vdash \boxempty : \tau^{\perp}, \boxempty : \tau}
\end{mathpar}

And the interpretation of “,” is tensor, which is just the $\mathsf{K}$ constructor.

$\mathsf{K}( \boxempty : \tau^{\perp}, \boxempty : \tau )$

Expanding this out and instantiating $\mathsf{K}$ to application, we would get

$\mathsf{App}( \boxempty : \tau \rhd l_{\mathsf{K}}, \boxempty : \tau )$

This yields exactly the property we are demanding.

More formally, we adapt the Lawvere theory as follows.

We add new sorts, $\chi^{\circ}$, and $\chi^{\bullet}$, $\chi^{\circ\bullet}$, and the following maps

\begin{itemize}
  \item $\mathsf{c}, l_{\mathsf{K}}, r_{\mathsf{K}} : 1 \rightarrow T$
  \item $\mathsf{K} : T^{2} \rightarrow T$
  \item $\mathsf{K}_{A} : 1 \rightarrow \chi^{\circ\bullet}$
  \item $\mathsf{K}_{\boxempty\blacksquare} : \chi^{\circ} \times \chi^{\bullet} \rightarrow \chi^{\circ\bullet}$
  \item $\mathsf{K}_{\boxempty}^{l} : T \times \chi^{\circ\bullet} \rightarrow \chi^{\circ\bullet}$
  \item $\mathsf{K}_{\boxempty}^{r} :  \chi^{\circ\bullet} \times T \rightarrow\chi^{\circ\bullet}$
  \item $?(-) : \chi^{\circ\bullet}  \rightarrow \chi^{\circ}$
  \item $(-)? : \chi^{\circ\bullet}  \rightarrow \chi^{\bullet}$
  \item $!(-) : \chi^{\circ}  \rightarrow T$
  \item $(-)! : \chi^{\bullet}  \rightarrow T$
  \item $@ : T^{2} \rightarrow T$
  \item $\mathsf{R} : T \rightarrow T$
  \item $\bindnasrepma_{\rho} : T^{2} \rightarrow T$
  \item $\sqcup_{\rho} : T^{2} \rightarrow T$
  \item $\rho : T^{2} \rightarrow T$             %%//( \x -> M N) -> M{N/x}     for( y <- x )P | x!(Q) -> P{@Q/y}
  \item $s(\rho(t,u)) = \mathsf{R}\mathsf{K}(t, u) $
  \item $t(\rho(t,u)) = f(t,u)$                      %%// f can mention R, e.g. if R is not a linear resource
  \item $\mathsf{K}(l_{\mathsf{K}}, u) = u$
  \item $\mathsf{K}(t, r_{\mathsf{K}}) = t$
  \item $@(\boxempty!,t) = t$
  \item $@(!\boxempty,t) = t$
  \item $@(\blacksquare ?,t) = t$
  \item $@(?\blacksquare,t) = t$
  % need to add polarities to these equations
  \item $@(\mathsf{K}_{\boxempty}^{l} (\chi, t)!, u) = \mathsf{K}(@(\chi, u), t)$
  \item $@(!\mathsf{K}_{\boxempty}^{r} (t, \chi), u) = \mathsf{K}(t, @(\chi, u))$
\end{itemize}

\begin{eqnarray*}
  \tau \RHD_{\mathsf{K}} \tau' & \triangleq  & \{ u | \exists t, \chi. u = ?\mathsf{K}_{\boxempty}^{r}(t, \chi),\forall u':\tau. (\exists \rho : u@u'\rightarrow v) \Rightarrow v:\tau' \} \\
  \tau'\LHD_{\mathsf{K}} \tau & \triangleq  & \{ t | \exists u, \chi. t = \mathsf{K}_{\boxempty}^{l}(\chi, u)?,\forall t':\tau. (\exists \rho : t@t'\rightarrow v) \Rightarrow v:\tau'\}
\end{eqnarray*}

In the sequel we will use the notation $\Gamma^{\circ}$ (respectively,
$\Delta^{\circ}$) to mean that the type context $\Gamma$ contains
exactly one term containing $\boxempty$ and no terms containing
$\blacksquare$. Dually, we will use the notation $\Gamma^{\bullet}$
(respectively, $\Delta^{\bullet}$) to mean that the type context
$\Gamma$ contains exactly one term containing $\blacksquare$ and no
terms containing $\boxempty$.

\subsection{Types}
We introduce additional arrow types to mirror the introduction of $?$.

\begin{mathpar}
  \inferrule* [lab=type] {} { \tau \bc  \top  | \tau \rhd \tau | \tau \lhd \tau | \tau \RHD \tau | \tau \LHD \tau | \mathsf{C} | \{\} | \tau \cup \tau | \mathsf{R}\tau | \mathsf{K}(\tau,\tau) | \rho_{\otimes}(\tau,\tau) | \rho_{\bindnasrepma}(\tau,\tau) | \rho_{\sqcap}(\tau,\tau) | \rho_{\sqcup}(\tau,\tau) }
\end{mathpar}

\subsection{Terms, their types and cuts}

\begin{mathpar}
  \inferrule* [lab=constant] {} {\vdash \mathsf{c} : \mathsf{C}}

  \inferrule* [lab=$\rho_{\otimes}$] {\vdash \Gamma, t : \tau   \vdash u : \tau', \Delta} {\vdash \Gamma, \mathsf{K}(t, u) : \rho_{\otimes}(\tau, \tau'), \Delta}

  \inferrule* [lab=$\rho_{\bindnasrepma}$] {\vdash \Gamma, t : \tau, u : \tau'} {\vdash \Gamma, \bindnasrepma_{\rho}(t, u) : \rho_{\bindnasrepma}(\tau, \tau')}

  \inferrule* [lab=$\rho_{\bindnasrepma\perp\otimes}$] {\vdash \Gamma, \bindnasrepma_{\rho} (t', u') : \rho_{\bindnasrepma}(\tau^{\perp}, \tau'^{\perp})  \vdash \mathsf{K}(t, u) : \rho_{\otimes}(\tau, \tau'), \Delta}{\vdash \Gamma, \mathsf{R}(\mathsf{K}(\mathsf{K}(t', t), \mathsf{K}(u', u))) : \mathsf{R}(r_{\mathsf{K}}), \Delta}

  \inferrule* [lab=$\rho_{\sqcap}$] {\vdash \Gamma, t : \tau, u : \tau'}{\vdash \Gamma, \mathsf{K}(t,u) : \rho_{\sqcap}(\tau,\tau')}

  \inferrule* [lab=$\rho_{\sqcup}$] {\vdash \Gamma, t : \tau, u : \tau'} {\vdash \Gamma, \sqcup(t,u) : \rho_{\sqcup}(\tau,\tau')}

  \inferrule* [lab=$\rho_{\sqcap\perp\sqcup}$] {\vdash \Gamma, \sqcup\rho (t, u) : \rho_{\sqcup}(\tau_{3} \rhd \tau_{1}^{\perp}, u:\tau_{3})  \vdash \mathsf{K}(t', u') : \rho_{\sqcap}(\tau_{2} \rhd \tau_{1}, \tau_{2}), \Delta } {\vdash \Gamma, \mathsf{R}(\mathsf{K}(\mathsf{K}( t, u), \mathsf{K}(t', u')) : \mathsf{R}(r_{\mathsf{K}}), \Delta}

  \inferrule* [lab=$\rho_{\perp}$] {\vdash\Gamma,  t' : \tau^{\perp}  \vdash t : \tau, \Delta }{\vdash \Gamma, \mathsf{R}(\mathsf{K}(t',t)) : \mathsf{R}(r_{\mathsf{K}}), \Delta}
\end{mathpar}

\subsection{Contexts, their types and cuts}

\subsubsection{Axiom}

% Need to add the ? introduction rules

\begin{mathpar}
  \inferrule* [lab=axiom] {} {\vdash \blacksquare : \tau^{\perp}, \boxempty : \tau} \\

  \inferrule* [lab=whynotleft] {\vdash \Gamma^{\bullet}, \boxempty : \tau_{1}, \chi^{\bullet} : \tau_{2}, \Delta^{\circ}, } {\vdash \Gamma^{\bullet}, \chi^{\bullet}? : \tau_{1} \RHD \tau_{2}, \Delta^{\circ}}

  \inferrule* [lab=whynotright] {\vdash \Gamma^{\circ}, \blacksquare : \tau_{1}, \chi^{\circ} : \tau_{2}, \Delta^{\bullet}} {\vdash \Gamma^{\circ}, ?\chi^{\circ}? : \tau_{1} \LHD \tau_{2}, \Delta^{\bullet}} \\

  \inferrule* [lab=rightarrow] {\vdash \Gamma^{\circ}, \blacksquare : \tau_{1} , \chi^{\circ} : \tau_{2}, \Delta^{\bullet}}{\vdash \Gamma^{\circ}, !\chi : \tau_{1} \lhd \tau_{2}, \Delta^{\bullet}} \\

  \inferrule* [lab=rightarrow] {\vdash \Gamma^{\bullet}, \boxempty : \tau_{1} , \chi^{\bullet} : \tau_{2}, \Delta^{\circ}}{\vdash \Gamma^{\bullet}, !\chi : \tau_{1} \rhd \tau_{2}, \Delta^{\circ}} \\

  \inferrule* [lab=$\rho_{\otimes}\perp\lhd$] {\vdash \Gamma, \mathsf{K}(\boxempty,u)! : \tau' \lhd \tau,  \vdash t : \tau, \Delta } {\vdash \Gamma, \mathsf{R}(\mathsf{K}(t,u)) : \mathsf{R}\tau', \Delta}

  \inferrule* [lab=$\rho_{\otimes}\perp\rhd$] {\vdash \Gamma, !\mathsf{K}(t,\boxempty) : \tau \rhd \tau',  \Delta \vdash u : \tau}{\vdash \Gamma, \mathsf{R}(\mathsf{K}(t,u)) : \mathsf{R}\tau', \Delta}
\end{mathpar}

\section{Examples}
\subsection{Applying the algorithm}
Now that we've worked out the type system in general above, we need to redo this example using the refined notation.

Below we give an example of the construction applied to the rho-combinators.
\subsubsection{Rho combinators}
Here is a relatively standard SoS presentation of the combinatorial system. 

\begin{mathpar}
  \inferrule* [lab=atom] {} { P \bc 0 \;|\; \mathsf{m}(a,\quotep{P}) \;|\; \mathsf{d}(a,b,c) \;|\; \mathsf{k}(a) \;|\; \mathsf{fw}(a,b) \;|\; \mathsf{b}_{\mathsf{r}}(a,b) \;|\; \mathsf{b}_{\mathsf{l}}(a,b) \;|\; \mathsf{s}(a,b,c) }
  \and
  \inferrule* [lab=process] {} {\bm \; *a \;|\; P|P}
  \and
  \inferrule* [lab=nominal] {} {a \bc \quotep{P}}
\end{mathpar}

Rewrite rules
\[\begin{array}{rl}
\mathsf{d}(a,b,c) | \mathsf{m}(a,\quotep{P}) & \red \mathsf{m}(b,\quotep{P}) | \mathsf{m}(c,\quotep{P}) \\
\mathsf{k}(a) | \mathsf{m}(a,\quotep{P}) & \red 0 \\
\mathsf{fw}(a,b) | \mathsf{m}(a,\quotep{P}) & \red \mathsf{m}(b,\quotep{P}) \\
\mathsf{b}_{\mathsf{r}}(a,b) | \mathsf{m}(a,\quotep{P}) & \red \mathsf{fw}(b,\quotep{P}) \\  
\end{array} \quad \quad
\begin{array}{rl}
  \mathsf{b}_{\mathsf{l}}(a,b) | \mathsf{m}(a,\quotep{P}) & \red \mathsf{fw}(\quotep{P},b) \\
  \mathsf{s}(a,b,c) | \mathsf{m}(a,\quotep{P}) & \red \mathsf{fw}(b,c) \\
  *(a) | \mathsf{m}(a,\quotep{P}) & \red P
\end{array}\]
\begin{mathpar}
  \inferrule* {{P} \red {P}'} {{{P} | {Q}} \red {{P}' | {Q}}}
  \and
  \inferrule* {{{P} \scong {P}'}, {{P}' \red {Q}'}, {{Q}' \scong {Q}}}{{P} \red {Q}}
\end{mathpar}

\begin{definition}
  The {\em structural congruence} $\equiv$
  between processes \cite{SangiorgiWalker} is the least congruence
  satisfying the commutative monoid laws
  (associativity, commutativity and $\pzero$ as identity) for parallel
  composition $|$ and $*(@(P)) \equiv P$.
\end{definition}

To interpret this presentation as a multi-sorted Lawvere theory per
the input format given above, we start with the Lawvere theory of
reflexive directed multigraphs and add new sorts, function symbols,
and equations.  The theory of reflexive directed multigraphs has

%% one sort P
%% function symbols src, trgt: P \rightarrow P
%% equations src \circ src = trgt \circ src = src, trgt \circ trgt = src \circ trgt = trgt

%% We adjoin a sort N for names. We express each of the syntactic generators as function symbols, thus 0 : 1 \rightarrow P, m : N x N \rightarrow P, @:P \rightarrow N, *:N \rightarrow P, |:P x P \rightarrow  P, etc. The base case rewrite rules are given in terms of the src and trgt functions, thus 

%% src( d(a, b, c) | m(a,d) \red m(b,d) | m(c,d) ) = d(a, b, c) | m(a,d)
%% trgt( d(a, b, c) | m(a,d) \red m(b,d) | m(c,d) ) = m(b,d) | m(c,d)

%% Note that rewrites do not occur within a name because there is no rule for making src and @ commute with each other.
%% The inference rule P \red P′ \Rightarrow P|Q \red P′|Q is encoded as an equation involving src, trgt, and |:

%% src( P | Q ) = src(P) | src(Q)
%% trgt( P | Q ) = trgt(P) | trgt(Q)

%% Structural congruence is encoded as equations:

%% 0 | P = P
%% P | Q = Q | P
%% (P | (Q | R)) = ((P | Q) | R)
%% *@P = P

%% Given that congruence is equality, the final inference rule is an identity.
\subsubsection{SKI}
Below, we give an explicit example of the construction applied to the $\mathsf{SKI}$ calculus.

%% Reduction contexts for tensor vs cut, with idempotent commutative monoids for collection
%% T

%% S, K, I, {}: 1 \rightarrow T
%% R: T \rightarrow T
%% (- -), \cup : T^{2} \rightarrow T
%% // Pars & plusses come from LHS with \geq 2 holes
%% \bindnasrepma\sigma: T^{3} \rightarrow T 
%% \bindnasrepma\kappa: T^{2} \rightarrow T
%% \oplus\sigma : T^{3} \rightarrow T 
%% \oplus\kappa : T^{2} \rightarrow T

%% RR = R
%% R(x y) = (Rx y)
%% \cup, {} associative, commutative, unital, idempotent

%% \sigma : (((RS x) y) z) \rhd ((Rx z) (y z))
%% \kappa : ((rK x) y) \rhd Rx
%% \iota : (RI x) \rhd Rx

%% [[-]]: Coll + (Term + Pars) \rhd Coll \circ (Term + Pars)

%% Types
%% \tau ::=  T | \tau \rhd \tau | S | K | \mid | {} | R\tau | (\tau \tau) | \tau \cup \tau | \sigma\bindnasrepma(\tau,\tau,\tau,\tau,\tau,\tau) | \sigma\oplus(\tau,\tau,\tau) | (kappa versions of \bindnasrepma\oplus)

%% We use the abbreviations
%% \sigma\otimes(A,B,C) \triangleq (((S A\rhd B\rhd C) A\rhd B) A) 
%% \sigma&(A,B,C,C') \triangleq (((S A\rhd B\rhd C' \rhd C) A\rhd B) A) 

%% Inference rules

%% \Gamma \vdash x: A\rhd B\rhd C  \Delta \vdash y: A\rhd B,  \Xi \vdash z: A
%% ------------------------------------------------------------------------------- \sigma tensor
%% \Gamma, \Delta, \Xi \vdash (((S x) y) z): \sigma\otimes(A,B,C)

%% \Gamma \vdash x: A\Rightarrow D\Rightarrow E\Rightarrow F, y: B\Rightarrow D\Rightarrow E, z: C\Rightarrow D
%% --------------------------------------------------------- \sigma par
%% \Gamma \vdash \bindnasrepma\sigma (x, y, z): \sigma\bindnasrepma(A,B,C,D,E,F)

%% \Gamma \vdash \bindnasrepma\sigma (x, y, z): \sigma\bindnasrepma(A,B,C,D,E,F)  \Delta \vdash (((S x') y') z'): \sigma\otimes(A,B,C)
%% ----------------------------------------------------------------------------------- \sigma par-tensor-cut
%% \Gamma, \Delta \vdash R(((S (x x')) (y y')) (z z')): RF
%% F is the property we'd like to hold at the end.



%% \Gamma \vdash x: A\rhd B\rhd C'\rhd C, y: A\rhd B, z: A
%% ---------------------------------------------- \sigma with
%% \Gamma, \Delta, \Xi \vdash (((S x) y) z): \sigma_{&} (A,B,C',C)


%% \Gamma \vdash x: A\rhd B\rhd C, y: A\rhdB, z: A
%% ------------------------------------------ \sigma plus
%% \Gamma \vdash \oplus(x, y, z): \sigma\oplus(A,B,C)

%% \Gamma \vdash (((S x) y) z): \sigma&(A,B,C',C)   \Delta \vdash \oplus(x', y', z'): \sigma\oplus(A',B',C')
%% --------------------------------------------------------------------------------  \sigma with-plus-cut
%% \Gamma, \Delta \vdash R((((S x) y) z) (((S x') y') z')): RC

%% C is the property we'd like to hold at the end.


%% \Gamma \vdash x: A\rhd B\rhd C  \Delta \vdash y: A\rhd B,  \Xi \vdash z: A
%% ----------------------------------------------------- \sigma cut is the special case of \sigma\otimes with \bindnasrepma\sigma (I, I, I)
%% \Gamma, \Delta, \Xi \vdash (((RS x) y) z): RC

%% Some useful properties and their proofs
%% TBD

\section{Main theorems}
In this section, we prove a cut-elimination theorem.
\subsection{Cut-elimination}
Every proof that uses a cut can be transformed into a proof that does
not use a cut.  Compilation from contextualized resource theory back
to original theory. In $\lambda$-calculus and {\pic}, $\mathsf{K}$ is
not directly interpreted as application or parallel,
respectively. Instead, it turns into a data type so we can extract the
info using a par term introduced in the contextualized resource
theory.  In $\rho$, there's no need because it's reflective.  But either
way, the term calculi are powerful enough to support the embedding of
the new terms back into the original.

It remains to show that the embedding is full and faithful. 

\section{Trampolines: implementing $\bindnasrepma_{\rho}$ and $\sqcup_{\rho}$ in the host theory}

The aim of the LADL programme is to generate a type system for a resource constrained version of a modern programming language algorithmically. Adding new terms to such a language, such as $\bindnasrepma_{\rho}$ and $\sqcup_{\rho}$ is disruptive and suboptimal. However, when the input to the algorithm is a computationally complete theory, like SKI or the rho-combinators, it is possible to implement $\bindnasrepma_{\rho}$ and $\sqcup_{\rho}$ as terms in the original theory and thus treat the type system as only talking about the original theory (modulo the resource constraint).

\section{Categorical construction}

% objects are types like on line 356
% morphisms are witnesses of entailment.  These are generated by the inference rules.
% If the witnesses contain enough information to reconstruct the proof, then we can say they are proofs.

% In the intuitionistic version, the left-hand side of an entailment
% is a typing context for the holes on the right.
% Composition is substitution.

% In the classical version, all LHSs of entailments are empty, so we are only
% generating morphisms out of the unit for tensor
% Morphisms come from annotating an entailment with a source and target type
% consistent with the entailment.
% e.g axiom gives four morphisms
% I -> A* tensor A
% A -> A
% A* -> A*
% A* tensor A -> I



\section{Conclusion and future work}

The aim of this construction is to generate a logic and its proof
theory from a notion of computation expressed as a graph-enriched
Lawvere theory. The logic respects both a Curry-Howard correspondence,
as well as realizability. Additionally, it enjoys a cut-elimination
property, and proof normalization corresponds precisely to the
operational semantics of the notion of computation provided in the
graph-enriched Lawvere theory.

We have not addressed nominal aspects of rewrite systems such as the
$\lambda$-calculus or the {\pic}. We note that there are two very
promising directions. One is captured in Clouston's work on nominal
Lawvere theories. \cite{DBLP:journals/jcss/Clouston14} The other is
expressed in Fiore's work on HOAS. \cite{DBLP:conf/csl/FioreH10} It
also bears mentioning that we can generate the names used by such a
nominal theory using reflection, ala Meredith and
Radestock. \cite{DBLP:conf/tgc/MeredithR05}

Also, in the spirit of Meredith and Radestock, we can seek to minimize
risk taken on in the theory in the form of “outside
influences.”Specifically, the evaluation context, $R$ does not have to
come from some external theory. It is possible to have two different
``copies'' of the same theory and have the $R$ of one come from terms
of the other and vice versa, in a mutually recursive definition.

\bibliographystyle{amsplain}
\bibliography{ladl}
\end{document}
 
